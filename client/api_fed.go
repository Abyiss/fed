/*
FED API

FED API is designed to create FEDACH and FEDWIRE dictionaries.  The FEDACH dictionary contains receiving depository financial institutions (RDFI’s) which are qualified to receive ACH entries.  The FEDWIRE dictionary contains receiving depository financial institutions (RDFI’s) which are qualified to receive WIRE entries.  This project implements a modern REST HTTP API for FEDACH Dictionary and FEDWIRE Dictionary.

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// FEDApiService FEDApi service
type FEDApiService service

type ApiPingRequest struct {
	ctx        context.Context
	ApiService *FEDApiService
}

func (r ApiPingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PingExecute(r)
}

/*
Ping Ping the FED service to check if running

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPingRequest
*/
func (a *FEDApiService) Ping(ctx context.Context) ApiPingRequest {
	return ApiPingRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FEDApiService) PingExecute(r ApiPingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FEDApiService.Ping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchFEDACHRequest struct {
	ctx           context.Context
	ApiService    *FEDApiService
	xRequestID    *string
	xUserID       *string
	name          *string
	routingNumber *string
	state         *string
	city          *string
	postalCode    *string
	limit         *int32
}

// Optional Request ID allows application developer to trace requests through the systems logs
func (r ApiSearchFEDACHRequest) XRequestID(xRequestID string) ApiSearchFEDACHRequest {
	r.xRequestID = &xRequestID
	return r
}

// Optional User ID used to perform this search
func (r ApiSearchFEDACHRequest) XUserID(xUserID string) ApiSearchFEDACHRequest {
	r.xUserID = &xUserID
	return r
}

// FEDACH Financial Institution Name
func (r ApiSearchFEDACHRequest) Name(name string) ApiSearchFEDACHRequest {
	r.name = &name
	return r
}

// FEDACH Routing Number for a Financial Institution
func (r ApiSearchFEDACHRequest) RoutingNumber(routingNumber string) ApiSearchFEDACHRequest {
	r.routingNumber = &routingNumber
	return r
}

// FEDACH Financial Institution State
func (r ApiSearchFEDACHRequest) State(state string) ApiSearchFEDACHRequest {
	r.state = &state
	return r
}

// FEDACH Financial Institution City
func (r ApiSearchFEDACHRequest) City(city string) ApiSearchFEDACHRequest {
	r.city = &city
	return r
}

// FEDACH Financial Institution Postal Code
func (r ApiSearchFEDACHRequest) PostalCode(postalCode string) ApiSearchFEDACHRequest {
	r.postalCode = &postalCode
	return r
}

// Maximum results returned by a search
func (r ApiSearchFEDACHRequest) Limit(limit int32) ApiSearchFEDACHRequest {
	r.limit = &limit
	return r
}

func (r ApiSearchFEDACHRequest) Execute() (*ACHDictionary, *http.Response, error) {
	return r.ApiService.SearchFEDACHExecute(r)
}

/*
SearchFEDACH Search FEDACH names and metadata

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchFEDACHRequest
*/
func (a *FEDApiService) SearchFEDACH(ctx context.Context) ApiSearchFEDACHRequest {
	return ApiSearchFEDACHRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ACHDictionary
func (a *FEDApiService) SearchFEDACHExecute(r ApiSearchFEDACHRequest) (*ACHDictionary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ACHDictionary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FEDApiService.SearchFEDACH")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fed/ach/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.routingNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingNumber", r.routingNumber, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
	}
	if r.postalCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "postalCode", r.postalCode, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Request-ID", r.xRequestID, "")
	}
	if r.xUserID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-User-ID", r.xUserID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchFEDWIRERequest struct {
	ctx           context.Context
	ApiService    *FEDApiService
	xRequestID    *string
	xUserID       *string
	name          *string
	routingNumber *string
	state         *string
	city          *string
	limit         *int32
}

// Optional Request ID allows application developer to trace requests through the systems logs
func (r ApiSearchFEDWIRERequest) XRequestID(xRequestID string) ApiSearchFEDWIRERequest {
	r.xRequestID = &xRequestID
	return r
}

// Optional User ID used to perform this search
func (r ApiSearchFEDWIRERequest) XUserID(xUserID string) ApiSearchFEDWIRERequest {
	r.xUserID = &xUserID
	return r
}

// FEDWIRE Financial Institution Name
func (r ApiSearchFEDWIRERequest) Name(name string) ApiSearchFEDWIRERequest {
	r.name = &name
	return r
}

// FEDWIRE Routing Number for a Financial Institution
func (r ApiSearchFEDWIRERequest) RoutingNumber(routingNumber string) ApiSearchFEDWIRERequest {
	r.routingNumber = &routingNumber
	return r
}

// FEDWIRE Financial Institution State
func (r ApiSearchFEDWIRERequest) State(state string) ApiSearchFEDWIRERequest {
	r.state = &state
	return r
}

// FEDWIRE Financial Institution City
func (r ApiSearchFEDWIRERequest) City(city string) ApiSearchFEDWIRERequest {
	r.city = &city
	return r
}

// Maximum results returned by a search
func (r ApiSearchFEDWIRERequest) Limit(limit int32) ApiSearchFEDWIRERequest {
	r.limit = &limit
	return r
}

func (r ApiSearchFEDWIRERequest) Execute() (*WIREDictionary, *http.Response, error) {
	return r.ApiService.SearchFEDWIREExecute(r)
}

/*
SearchFEDWIRE Search FEDWIRE names and metadata

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSearchFEDWIRERequest
*/
func (a *FEDApiService) SearchFEDWIRE(ctx context.Context) ApiSearchFEDWIRERequest {
	return ApiSearchFEDWIRERequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WIREDictionary
func (a *FEDApiService) SearchFEDWIREExecute(r ApiSearchFEDWIRERequest) (*WIREDictionary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WIREDictionary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FEDApiService.SearchFEDWIRE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fed/wire/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.routingNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "routingNumber", r.routingNumber, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.city != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "city", r.city, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRequestID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Request-ID", r.xRequestID, "")
	}
	if r.xUserID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-User-ID", r.xUserID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
